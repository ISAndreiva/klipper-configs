
[gcode_macro POWER_OFF_PRINTER]
gcode:
  {action_call_remote_method("set_device_power",
                             device="Ender3_Power",
                             state="off")}

[gcode_macro M300]
gcode:
    # Use a default 1kHz tone if S is omitted.
    {% set S = params.S|default(1000)|int %}
    # Use a 10ms duration is P is omitted.
    {% set P = params.P|default(100)|int %}
    SET_PIN PIN=BEEPER_pin VALUE=0.5 CYCLE_TIME={ 1.0/S if S > 0 else 1 }
    G4 P{P}
    SET_PIN PIN=BEEPER_pin VALUE=0


[gcode_macro UNLOAD_FILAMENT]
gcode:
    SAVE_GCODE_STATE NAME=__filament__unload
    M83
    G1 E10 F240
    G1 E-50 F240
    G1 E-70 F960
    RESTORE_GCODE_STATE NAME=__filament__unload

[gcode_macro LOAD_FILAMENT]
gcode:
    SAVE_GCODE_STATE NAME=__filament__load
    M83
    G1 E50 F960
    G1 E70 F240
    RESTORE_GCODE_STATE NAME=__filament__load

[gcode_macro M600]
gcode:
    SAVE_GCODE_STATE NAME=M600_state
    PAUSE
    G1 E-50 F1000
    RESTORE_GCODE_STATE NAME=M600_state

[gcode_macro CANCEL_PRINT]
rename_existing: BASE_CANCEL_PRINT
gcode:
    TURN_OFF_HEATERS
    CLEAR_PAUSE
    BASE_CANCEL_PRINT

[gcode_macro PAUSE]
rename_existing: BASE_PAUSE
gcode:
    ##### set defaults #####
    {% set x = params.X|default(0) %}      #edit to your park position
    {% set y = params.Y|default(-10) %}      #edit to your park position
    {% set z = params.Z|default(10)|float %} #edit to your park position
    {% set e = params.E|default(1) %}        #edit to your retract length
    ##### calculate save lift position #####
    {% set max_z = printer.toolhead.axis_maximum.z|float %}
    {% set act_z = printer.toolhead.position.z|float %}
    {% set lift_z = z|abs %}
    {% if act_z < (max_z - lift_z) %}
        {% set z_safe = lift_z %}
    {% else %}
        {% set z_safe = max_z - act_z %}
    {% endif %}
    ##### end of definitions #####
    SAVE_GCODE_STATE NAME=PAUSE_state
    BASE_PAUSE
    G91
    G1 E-{e} F2100
    G1 Z{z_safe}
    G90
    G1 X{x} Y{y} F6000


[gcode_macro RESUME]
rename_existing: BASE_RESUME
gcode:
    ##### set defaults #####
    {% set e = params.E|default(2) %} #edit to your retract length
    G91
    G1 E{e} F2100
    G90
    RESTORE_GCODE_STATE NAME=PAUSE_state MOVE=1
    BASE_RESUME

#########################################
########## ADAPTIVE BED MESH ############
#########################################
# Written by Frix_x#0161 #

### What is it ? ###

# The adaptive bed mesh is simple: it's a normal bed mesh, but only "where" and "when" it's necessary.
# Sometime I print small parts, sometime I print full plates and I like to get a precise bed_mesh (like 9x9 or more). However, it take a
# lot of time and it's useless to probe all the plate for only a 5cm² part in the center. So this is where the adaptive bed mesh is helping:
# 1. It get the corners coordinates of the fisrt layer surface from the slicer
# 2. It compute a new set of points to probe on this new zone to get at least the same precision as your standard bed mesh. For example, if
#    a normal bed mesh is set to 9x9 for 300mm², it will then compute 3x3 for a 100mm² surface. Also if for whatever reason your parts are in
#    the corner of the build plate (like for a damaged PEI in the center), it will follow them to probe this exact area.
# 3. As the probed point computed are odd, it will also compute the new relative reference index point in the center of the zone
# 4. To go further, the macro will not do any bed_mesh if there is less than 3x3 points to probe (very small part alone) and choose/change the
#    algorithm (bicubic/lagrange) depending of the size and shape of the mesh computed (like 3x3 vs 3x9)

### Installation ###
# 1. In you custom start gcode from SuperSlicer, add the SIZE argument to your PRINT_START macro like this:
#    PRINT_START [all your shit..] SIZE={first_layer_print_min[0]}_{first_layer_print_min[1]}_{first_layer_print_max[0]}_{first_layer_print_max[1]}
# 2. Configure a normal [bed_mesh] section in your config as you want for your machine (it will be the base to compute the new adaptive bed mesh). Keep
#    in mind that you can push the precision a little bit with a mesh of 9x9 for example as not all the points will be probed.
# 3. VERY IMPORTANT : be sure to put the "mesh_pps" entry in the [bed_mesh] section (you can choose what you want or let it to default, but it's mandatory
#    to really specify it in your config for my macro to work.
# 4. In your PRINT_START macro, get the SIZE argument and pass it to the ADAPTIVE_BED_MESH to start the probing sequence like so:
#    {% set FL_SIZE = params.SIZE|default("0_0_0_0")|string %}
#    ADAPTIVE_BED_MESH SIZE={FL_SIZE}
# 5. Optional: my macro is using the RESPOND command for debugging purposes: add the [respond] section to your config or delete all the RESPOND lines in my macro

# Feel free to ping me on Discord (Frix_x#0161) if you need help or have any comments to improve it :)


[gcode_macro ADAPTIVE_BED_MESH]
description: Perform a bed mesh, but only where and when it's needed
gcode:
    status_meshing
    # 1 ----- GET ORIGINAL BEDMESH PARAMS FROM CONFIG ----------------------
    {% set xMinConf, yMinConf = printer["configfile"].config["bed_mesh"]["mesh_min"].split(',')|map('trim')|map('int') %}
    {% set xMaxConf, yMaxConf = printer["configfile"].config["bed_mesh"]["mesh_max"].split(',')|map('trim')|map('int') %}
    {% set xProbeCntConf, yProbeCntConf = printer["configfile"].config["bed_mesh"]["probe_count"].split(',')|map('trim')|map('int') %}
    {% set algo = printer["configfile"].config["bed_mesh"]["algorithm"] %}
    {% set xMeshPPS, yMeshPPS = printer["configfile"].config["bed_mesh"]["mesh_pps"].split(',')|map('trim')|map('int') %}
    # If the SIZE parameter is defined and set not a dummy placeholder, we do the adaptive
    # bed mesh logic. If it's ommited, we still do the original BED_MESH_CALIBRATE function
    {% if params.SIZE is defined and params.SIZE != "0_0_0_0" %}

        # 2 ----- GET MESH SIZE AND MARGIN FROM MACRO CALL --------------------
        {% set xMinSpec, yMinSpec, xMaxSpec, yMaxSpec = params.SIZE.split('_')|map('trim')|map('int') %}
        {% set margin = params.MARGIN|default(5)|int %}

        # 3 ----- APPLY MARGINS ----------------------------------------------
        # We use min/max function as we want it to be constrained by the original
        # bedmesh size. This will avoid going outside the machine limits
        {% set xMin = [xMinConf, (xMinSpec - margin)]|max %}
        {% set xMax = [xMaxConf, (xMaxSpec + margin)]|min %}
        {% set yMin = [yMinConf, (yMinSpec - margin)]|max %}
        {% set yMax = [yMaxConf, (yMaxSpec + margin)]|min %}

        # 4 ----- COMPUTE A NEW PROBE COUNT ----------------------------------
        # The goal is to have at least the same precision as from the config. So we compute an equivalent number
        # of probe points on each X/Y dimensions (distance between two points should be the same as in the config)
        {% set xProbeCnt = ((xMax - xMin) * xProbeCntConf / (xMaxConf - xMinConf))|round(0, 'ceil')|int %}
        {% set yProbeCnt = ((yMax - yMin) * yProbeCntConf / (yMaxConf - yMinConf))|round(0, 'ceil')|int %}

        # Then, three possibilities :
        # a) Both dimensions have less than 3 probe points : the bed_mesh is not needed as it's a small print.
        # b) If one of the dimension is less than 3 and the other is greater. The print looks to be elongated and
        #    need the adaptive bed_mesh : we add probe points to the small direction to reach 3 and be able to do it.
        # c) If both direction are greater than 3, we need the adaptive bed_mesh and it's ok.
        # At the end we control (according to Klipper bed_mesh method: "_verify_algorithm") that the computed probe_count is
        # valid according to the choosen algorithm or change it if needed.
        {% if xProbeCnt < 3 and yProbeCnt < 3 %}
            RESPOND MSG="Adaptive bed mesh: mesh not needed"
            
        {% else %}
            {% set xProbeCnt = [3, xProbeCnt]|max %}
            {% set yProbeCnt = [3, yProbeCnt]|max %}

            # We verify that the number of probe points on each axis is odd or add
            # one to it. This is to have a relative_reference_index point at the center of the mesh
            {% if xProbeCnt % 2 == 0 %}
                {% set xProbeCnt = xProbeCnt + 1 %}
            {% endif %}
            {% if yProbeCnt % 2 == 0 %}
                {% set yProbeCnt = yProbeCnt + 1 %}
            {% endif %}

            # Check of the probe points and interpolation algorithms according to Klipper code
            {% if xMeshPPS != 0 or yMeshPPS != 0 %}
                {% set probeCntMin = [xProbeCnt, yProbeCnt]|min %}
                {% set probeCntMax = [xProbeCnt, yProbeCnt]|max %}
                {% if algo == "lagrange" and probeCntMax > 6 %}
                    # Lagrange interpolation tends to oscillate when using more than 6 samples: swith to bicubic
                    {% set algo = "bicubic" %}
                {% endif %}
                {% if algo == "bicubic" and probeCntMin < 4 %}
                    {% if probeCntMax > 6 %}
                        # Impossible case: need to add probe point on the small axis to be >= 4 (we want 5 to keep it odd)
                        {% if xProbeCnt > yProbeCnt %}
                            {% set yProbeCnt = 5 %}
                        {% else %}
                            {% set xProbeCnt = 5 %}
                        {% endif %}
                    {% else %}
                        # In this case bicubic is not adapted (less than 4 points): switch to lagrange
                        {% set algo = "lagrange" %}
                    {% endif %}
                {% endif %}
            {% endif %}

            # 5 ----- COMPUTE THE RELATIVE_REFERENCE_INDEX POINT --------------------
            {% set rRefIndex = (((xProbeCnt * yProbeCnt) - 1) / 2)|int %}

            # 6 ----- FORMAT THE PARAMETERS TO CALL BED_MESH_CALIBRATE --------------
            {% set mesh_min = "%d,%d"|format(xMin, yMin) %}
            {% set mesh_max = "%d,%d"|format(xMax, yMax) %}
            {% set probe_count = "%d,%d"|format(xProbeCnt, yProbeCnt) %}
            RESPOND MSG="Adaptive bed mesh: MESH_MIN={mesh_min} MESH_MAX={mesh_max} PROBE_COUNT={probe_count} RELATIVE_REFERENCE_INDEX={rRefIndex} ALGORITHM={algo}"
            BED_MESH_CALIBRATE MESH_MIN={mesh_min} MESH_MAX={mesh_max} PROBE_COUNT={probe_count} ALGORITHM={algo}
        {% endif %}
    {% else %}
        RESPOND MSG="Adaptive bed mesh: nominal bed mesh"
        BED_MESH_CALIBRATE
    {% endif %}


# Home, get position, throw around toolhead, home again.
# If MCU stepper positions (first line in GET_POSITION) are greater than a full step different (your number of microsteps), then skipping occured.
# We only measure to a full step to accomodate for endstop variance.
# Example: TEST_SPEED SPEED=300 ACCEL=5000 ITERATIONS=10

# Home, get position, throw around toolhead, home again.
# If MCU stepper positions (first line in GET_POSITION) are greater than a full step different (your number of microsteps), then skipping occured.
# We only measure to a full step to accomodate for endstop variance.
# Example: TEST_SPEED SPEED=300 ACCEL=5000 ITERATIONS=10

[gcode_macro TEST_SPEED]
gcode:
	# Speed
	{% set speed  = params.SPEED|default(printer.configfile.settings.printer.max_velocity)|int %}
	# Iterations
	{% set iterations = params.ITERATIONS|default(5)|int %}
	# Acceleration
	{% set accel  = params.ACCEL|default(printer.configfile.settings.printer.max_accel)|int %}
	# Bounding inset for large pattern (helps prevent slamming the toolhead into the sides after small skips, and helps to account for machines with imperfectly set dimensions)
	{% set bound = params.BOUND|default(20)|int %}
	# Size for small pattern box
	{% set smallpatternsize = SMALLPATTERNSIZE|default(20)|int %}
	
	# Large pattern
		# Max positions, inset by BOUND
		{% set x_min = printer.toolhead.axis_minimum.x + bound %}
		{% set x_max = printer.toolhead.axis_maximum.x - bound %}
		{% set y_min = printer.toolhead.axis_minimum.y + bound %}
		{% set y_max = printer.toolhead.axis_maximum.y - bound %}
	
	# Small pattern at center
		# Find X/Y center point
		{% set x_center = (printer.toolhead.axis_minimum.x|float + printer.toolhead.axis_maximum.x|float ) / 2 %}
		{% set y_center = (printer.toolhead.axis_minimum.y|float + printer.toolhead.axis_maximum.y|float ) / 2 %}
		
		# Set small pattern box around center point
		{% set x_center_min = x_center - (smallpatternsize/2) %}
		{% set x_center_max = x_center + (smallpatternsize/2) %}
		{% set y_center_min = y_center - (smallpatternsize/2) %}
		{% set y_center_max = y_center + (smallpatternsize/2) %}

	# Save current gcode state (absolute/relative, etc)
	SAVE_GCODE_STATE NAME=TEST_SPEED
	
	# Output parameters to g-code terminal
	{ action_respond_info("TEST_SPEED: starting %d iterations at speed %d, accel %d" % (iterations, speed, accel)) }

	# Absolute positioning
	G90
	
	# Set new limits
	SET_VELOCITY_LIMIT VELOCITY={speed} ACCEL={accel} ACCEL_TO_DECEL={accel / 2}

	# Home and get position for comparison later:
		G28
		# QGL if not already QGLd (only if QGL section exists in config)
		{% if printer.configfile.settings.quad_gantry_level %}
			{% if printer.quad_gantry_level.applied == False %}
				QUAD_GANTRY_LEVEL
				G28 Z
			{% endif %}
		{% endif %}	
		G0 X{printer.toolhead.axis_maximum.x} Y{printer.toolhead.axis_maximum.y} Z20 F{30*60}
		G4 P1000 
		GET_POSITION

	# Go to starting position
	G0 X{x_min} Y{y_min} Z{bound + 10} F{speed*60}

	{% for i in range(iterations) %}
		# Large pattern
			# Diagonals
			G0 X{x_min} Y{y_min} F{speed*60}
			G0 X{x_max} Y{y_max} F{speed*60}
			G0 X{x_min} Y{y_min} F{speed*60}
			G0 X{x_max} Y{y_min} F{speed*60}
			G0 X{x_min} Y{y_max} F{speed*60}
			G0 X{x_max} Y{y_min} F{speed*60}
			
			# Box
			G0 X{x_min} Y{y_min} F{speed*60}
			G0 X{x_min} Y{y_max} F{speed*60}
			G0 X{x_max} Y{y_max} F{speed*60}
			G0 X{x_max} Y{y_min} F{speed*60}
		
		# Small pattern
			# Small diagonals 
			G0 X{x_center_min} Y{y_center_min} F{speed*60}
			G0 X{x_center_max} Y{y_center_max} F{speed*60}
			G0 X{x_center_min} Y{y_center_min} F{speed*60}
			G0 X{x_center_max} Y{y_center_min} F{speed*60}
			G0 X{x_center_min} Y{y_center_max} F{speed*60}
			G0 X{x_center_max} Y{y_center_min} F{speed*60}
			
			# Small box
			G0 X{x_center_min} Y{y_center_min} F{speed*60}
			G0 X{x_center_min} Y{y_center_max} F{speed*60}
			G0 X{x_center_max} Y{y_center_max} F{speed*60}
			G0 X{x_center_max} Y{y_center_min} F{speed*60}
	{% endfor %}

	# Restore max speed/accel/accel_to_decel to their configured values
	SET_VELOCITY_LIMIT VELOCITY={printer.configfile.settings.printer.max_velocity} ACCEL={printer.configfile.settings.printer.max_accel} ACCEL_TO_DECEL={printer.configfile.settings.printer.max_accel_to_decel} 

	# Re-home and get position again for comparison:
        G28
		# Go to XY home positions (in case your homing override leaves it elsewhere)
		G0 X{printer.toolhead.axis_maximum.x} Y{printer.toolhead.axis_maximum.y} Z20 F{30*60}
        G4 P10000
		GET_POSITION

	# Restore previous gcode state (absolute/relative, etc)
	RESTORE_GCODE_STATE NAME=TEST_SPEED



[gcode_macro SENSORLESS_HOME_X]
gcode:
    {% set HOME_CUR = 0.650 %}
    {% set driver_config = printer.configfile.settings['tmc2130 stepper_x'] %}
    {% set RUN_CUR = driver_config.run_current %}
    # Set current for sensorless homing
    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={HOME_CUR}
    # Pause to ensure driver stall flag is clear
    G4 P2000
    # Home
    G28 X0
    # Move away
    G90
    G1 X3 F1200
    # Set current during print
    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={RUN_CUR}


[gcode_macro SENSORLESS_HOME_Y]
gcode:
    {% set HOME_CUR =  0.650 %}
    {% set driver_config = printer.configfile.settings['tmc2130 stepper_y'] %}
    {% set RUN_CUR = driver_config.run_current %}
    # Set current for sensorless homing
    SET_TMC_CURRENT STEPPER=stepper_y CURRENT={HOME_CUR}
    # Pause to ensure driver stall flag is clear
    {% if "x" not in printer.toolhead.homed_axes %}
    G4 P2000
    {% endif %}
    # Home
    G28 Y0
    # Move away
    G90
    G1 Y3 F1200
    # Set current during print
    SET_TMC_CURRENT STEPPER=stepper_y CURRENT={RUN_CUR}

[gcode_macro Clean_Nozzle]
gcode:
    G90
    G1 Y35 X207.5 Z5   F12000  
    G4 P100    
    G1 Y-8
    G91
    {% for i in range(5) %}
          G1 X12.5 F6000
          G1 X-25  F6000
          G1 X12.5 F6000
    {% endfor %}
    G1 Z10 Y40
    G90
